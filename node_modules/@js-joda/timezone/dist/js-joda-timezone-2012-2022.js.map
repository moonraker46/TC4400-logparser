{"version":3,"sources":["webpack://JSJodaTimezone/webpack/universalModuleDefinition","webpack://JSJodaTimezone/webpack/bootstrap","webpack://JSJodaTimezone/./src/MomentZoneRules.js","webpack://JSJodaTimezone/./src/MomentZoneRulesProvider.js","webpack://JSJodaTimezone/./src/auto-plug.js","webpack://JSJodaTimezone/./src/js-joda-timezone.js","webpack://JSJodaTimezone/./src/plug.js","webpack://JSJodaTimezone/./src/system-default-zone.js","webpack://JSJodaTimezone/./src/tzdbData.js","webpack://JSJodaTimezone/./src/unpack.js","webpack://JSJodaTimezone/external {\"amd\":\"@js-joda/core\",\"commonjs\":\"@js-joda/core\",\"commonjs2\":\"@js-joda/core\",\"root\":\"JSJoda\"}"],"names":["MomentZoneRules","tzdbInfo","_tzdbInfo","_ldtUntils","LDTUntils","untils","offsets","length","instant","epochMilli","toEpochMilli","offsetOfEpochMilli","index","binarySearch","ZoneOffset","ofTotalSeconds","_offsetByIndexInSeconds","localDateTime","info","_offsetInfo","ZoneOffsetTransition","offsetBefore","ldtBinarySearch","offsetIndex","ldtBefore","get","Math","max","ldtAfter","min","size","offsetAfter","compareTo","of","offsetInSeconds","validOffsets","notSupported","offset","some","o","equals","other","name","ZoneRules","_tzdbUntils","tzdbOffsets","_tzdbOffsets","epochMillis","Infinity","LocalDateTime","MAX","Instant","ofEpochMilli","offset1","zone1","ldt1","ofInstant","nextIndex","offset2","zone2","ldt2","_generateTupple","ldtTupple","_getTupple","array","value","hi","lo","mid","isBefore","tzdbOffset","roundDown","r","ceil","floor","msg","Error","TZDB_DATA","TZDB_VERSION","AVAILABLE_ZONE_IDS","zones","links","MomentZoneRulesProvider","zoneId","tzdbZoneInfo","DateTimeException","packedJson","version","packedZoneInfo","unpack","push","packedLink","link","split","ZoneRulesProvider","autoPlug","use","plug","loadTzdbData","latest","jsJoda","getRules","getAvailableZoneIds","getTzdbData","extendSystemDefaultZoneId","ZoneId","getResolvedZoneId","resolvedTimeZone","Intl","DateTimeFormat","resolvedOptions","timeZone","err","resolvedZoneId","systemDefault","charCodeToInt","charCode","unpackBase60","string","i","parts","whole","fractional","multiplier","num","out","sign","charCodeAt","arrayToInt","intToUntil","round","mapIndices","source","indices","data","abbrs","population"],"mappings":"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","file":"js-joda-timezone-2012-2022.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@js-joda/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@js-joda/core\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JSJodaTimezone\"] = factory(require(\"@js-joda/core\"));\n\telse\n\t\troot[\"JSJodaTimezone\"] = factory(root[\"JSJoda\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__js_joda_core__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js-joda-timezone.js\");\n","/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {\n    LocalDateTime, Instant, ZoneOffset, ZoneOffsetTransition, ZoneRules\n} from '@js-joda/core';\n\nexport class MomentZoneRules extends ZoneRules{\n    constructor(tzdbInfo){\n        super();\n        this._tzdbInfo = tzdbInfo;\n        this._ldtUntils = new LDTUntils(this._tzdbInfo.untils, this._tzdbInfo.offsets);\n    }\n    /**\n     * Checks of the zone rules are fixed, such that the offset never varies.\n     *\n     * @return {boolean} true if the time-zone is fixed and the offset never changes\n     */\n    isFixedOffset(){\n        return this._tzdbInfo.offsets.length === 1;\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets the offset applicable at the specified instant in these rules.\n     * <p>\n     * The mapping from an instant to an offset is simple, there is only\n     * one valid offset for each instant.\n     * This method returns that offset.\n     *\n     * @param {Instant} instant - the instant to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    offsetOfInstant(instant){\n        const epochMilli = instant.toEpochMilli();\n        return this.offsetOfEpochMilli(epochMilli);\n    }\n\n    /**\n     * Gets the offset applicable at the specified epochMilli in these rules.\n     *\n     * The method is for javascript performance optimisation.\n     *\n     * @param {number} epochMilli - the epoch millisecond to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    offsetOfEpochMilli(epochMilli){\n        const index  = binarySearch(this._tzdbInfo.untils, epochMilli);\n        return ZoneOffset.ofTotalSeconds(this._offsetByIndexInSeconds(index));\n    }\n\n\n    /**\n     * Gets a suitable offset for the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns the single offset in the Normal case, and in the Gap or Overlap\n     * case it returns the offset before the transition.\n     * <p>\n     * Since, in the case of Gap and Overlap, the offset returned is a \"best\" value, rather\n     * than the \"correct\" value, it should be treated with care. Applications that care\n     * about the correct offset should use a combination of this method,\n     * {@link #getValidOffsets(LocalDateTime)} and {@link #getTransition(LocalDateTime)}.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the best available offset for the local date-time, not null\n     */\n    offsetOfLocalDateTime(localDateTime){\n        const info = this._offsetInfo(localDateTime);\n        if (info instanceof ZoneOffsetTransition) {\n            return info.offsetBefore();\n        }\n        return info;\n    }\n\n    _offsetInfo(localDateTime) {\n        const index  = ldtBinarySearch(this._ldtUntils, localDateTime);\n        const offsetIndex = index >> 1;\n\n        if (index % 2 === 1){\n            const ldtBefore = this._ldtUntils.get(Math.max(index-1, 0));\n            const ldtAfter = this._ldtUntils.get(Math.min(index, this._ldtUntils.size-1));\n            const offsetBefore = ZoneOffset.ofTotalSeconds(this._offsetByIndexInSeconds(offsetIndex));\n            const offsetAfter = ZoneOffset.ofTotalSeconds(this._offsetByIndexInSeconds(Math.min(offsetIndex+1, this._tzdbInfo.offsets.length-1)));\n            // console.log(offsetBefore.toString(), offsetAfter.toString());\n            if (offsetBefore.compareTo(offsetAfter) > 0) {\n                // gap\n                // console.log('gap', ldtBefore.toString(), localDateTime.toString(), ldtAfter.toString());\n                return ZoneOffsetTransition.of(ldtBefore, offsetBefore, offsetAfter);\n            } else {\n                // overlap\n                // console.log('overlap', ldtBefore.toString(), localDateTime.toString(), ldtAfter.toString());\n                return ZoneOffsetTransition.of(ldtAfter, offsetBefore, offsetAfter);\n            }\n        }\n        return ZoneOffset.ofTotalSeconds(this._offsetByIndexInSeconds(offsetIndex));\n    }\n\n    _offsetByIndexInSeconds(index){\n        return -offsetInSeconds(this._tzdbInfo.offsets[index]);\n    }\n\n    /**\n     * Gets the offset applicable at the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns that list of valid offsets, which is a list of size 0, 1 or 2.\n     * In the case where there are two offsets, the earlier offset is returned at index 0\n     * and the later offset at index 1.\n     * <p>\n     * There are various ways to handle the conversion from a {@code LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  List<ZoneOffset> validOffsets = rules.getOffset(localDT);\n     *  if (validOffsets.size() == 1) {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = validOffsets.get(0);\n     *  } else {\n     *    // Gap or Overlap: determine what to do from transition (which will be non-null)\n     *    ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  }\n     * </pre>\n     * <p>\n     * In theory, it is possible for there to be more than two valid offsets.\n     * This would happen if clocks to be put back more than once in quick succession.\n     * This has never happened in the history of time-zones and thus has no special handling.\n     * However, if it were to happen, then the list would return more than 2 entries.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query for valid offsets, not null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition | ZoneOffset[]} the list of valid offsets, may be immutable, not null\n     */\n    validOffsets(localDateTime){\n        const info = this._offsetInfo(localDateTime);\n        if (info instanceof ZoneOffsetTransition) {\n            return info.validOffsets();\n        }\n        return [info];\n    }\n\n    /**\n     * Gets the offset transition applicable at the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * A transition is used to model the cases of a Gap or Overlap.\n     * The Normal case will return null.\n     * <p>\n     * There are various ways to handle the conversion from a {@code LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  if (trans != null) {\n     *    // Gap or Overlap: determine what to do from transition\n     *  } else {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = rule.getOffset(localDT);\n     *  }\n     * </pre>\n     *\n     * @param {LocalDateTime} localDateTime  the local date-time to query for offset transition, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the offset transition, null if the local date-time is not in transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    transition(localDateTime){\n        const info = this._offsetInfo(localDateTime);\n        if (info instanceof ZoneOffsetTransition) {\n            return info;\n        }\n        return null;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the standard offset for the specified instant in this zone.\n     * <p>\n     * This provides access to historic information on how the standard offset\n     * has changed over time.\n     * The standard offset is the offset before any daylight saving time is applied.\n     * This is typically the offset applicable during winter.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the standard offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    standardOffset(instant){\n        notSupported('ZoneRules.standardOffset');\n    }\n\n    /**\n     * Gets the amount of daylight savings in use for the specified instant in this zone.\n     * <p>\n     * This provides access to historic information on how the amount of daylight\n     * savings has changed over time.\n     * This is the difference between the standard offset and the actual offset.\n     * Typically the amount is zero during winter and one hour during summer.\n     * Time-zones are second-based, so the nanosecond part of the duration will be zero.\n     *\n     * @param {Instant} instant - the instant to find the daylight savings for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {Duration} the difference between the standard and actual offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    daylightSavings(instant){\n        notSupported('ZoneRules.daylightSavings');\n    }\n\n    /**\n     * Checks if the specified instant is in daylight savings.\n     * <p>\n     * This checks if the standard and actual offsets are the same at the specified instant.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {boolean} the standard offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    isDaylightSavings(instant) {\n        notSupported('ZoneRules.isDaylightSavings');\n    }\n\n    /**\n     * Checks if the offset date-time is valid for these rules.\n     * <p>\n     * To be valid, the local date-time must not be in a gap and the offset\n     * must match the valid offsets.\n     *\n     * @param {LocalDateTime} localDateTime - the date-time to check, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @param {ZoneOffset} offset - the offset to check, null returns false\n     * @return {boolean} true if the offset date-time is valid for these rules\n     */\n    isValidOffset(localDateTime, offset){\n        return this.validOffsets(localDateTime).some( o => o.equals(offset));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the next transition after the specified instant.\n     * <p>\n     * This returns details of the next transition after the specified instant.\n     * For example, if the instant represents a point where \"Summer\" daylight savings time\n     * applies, then the method will return the transition to the next \"Winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the next transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the next transition after the specified instant, null if this is after the last transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    nextTransition(instant){\n        notSupported('ZoneRules.nextTransition');\n    }\n\n    /**\n     * Gets the previous transition before the specified instant.\n     * <p>\n     * This returns details of the previous transition after the specified instant.\n     * For example, if the instant represents a point where \"summer\" daylight saving time\n     * applies, then the method will return the transition from the previous \"winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the previous transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the previous transition after the specified instant, null if this is before the first transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    previousTransition(instant){\n        notSupported('ZoneRules.previousTransition');\n    }\n\n    /**\n     * Gets the complete list of fully defined transitions.\n     * <p>\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link #getTransitionRules()}. This method returns those transitions that have\n     * been fully defined. These are typically historical, but may be in the future.\n     * <p>\n     * The list will be empty for fixed offset rules and for any time-zone where there has\n     * only ever been a single offset. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransition[]} an immutable list of fully defined transitions, not null\n     */\n    transitions(){\n        notSupported('ZoneRules.transitions');\n    }\n\n    /**\n     * Gets the list of transition rules for years beyond those defined in the transition list.\n     * <p>\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link #getTransitions()}. This method returns instances of {@link ZoneOffsetTransitionRule}\n     * that define an algorithm for when transitions will occur.\n     * <p>\n     * For any given {@code ZoneRules}, this list contains the transition rules for years\n     * beyond those years that have been fully defined. These rules typically refer to future\n     * daylight saving time rule changes.\n     * <p>\n     * If the zone defines daylight savings into the future, then the list will normally\n     * be of size two and hold information about entering and exiting daylight savings.\n     * If the zone does not have daylight savings, or information about future changes\n     * is uncertain, then the list will be empty.\n     * <p>\n     * The list will be empty for fixed offset rules and for any time-zone where there is no\n     * daylight saving time. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransitionRule[]} an immutable list of transition rules, not null\n     */\n    transitionRules(){\n        notSupported('ZoneRules.transitionRules');\n    }\n\n    /**\n     *\n     * @param other\n     * @returns {boolean}\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof MomentZoneRules) {\n            return this._tzdbInfo === other._tzdbInfo;\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return this._tzdbInfo.name;\n    }\n}\n\nclass LDTUntils {\n    constructor(_tzdbUntils, tzdbOffsets) {\n        this._tzdbUntils = _tzdbUntils;\n        this._tzdbOffsets = tzdbOffsets;\n        this._ldtUntils = [];\n        this.size = this._tzdbUntils.length * 2;\n    }\n\n\n    _generateTupple(index) {\n        const epochMillis = this._tzdbUntils[index];\n        if (epochMillis === Infinity) {\n            return [LocalDateTime.MAX, LocalDateTime.MAX];\n        }\n        const instant = Instant.ofEpochMilli(epochMillis);\n\n        const offset1 = offsetInSeconds(this._tzdbOffsets[index]);\n        const zone1 = ZoneOffset.ofTotalSeconds(-offset1);\n        const ldt1 = LocalDateTime.ofInstant(instant, zone1);\n\n        const nextIndex = Math.min(index + 1, this._tzdbOffsets.length - 1);\n        const offset2 = offsetInSeconds(this._tzdbOffsets[nextIndex]);\n        const zone2 = ZoneOffset.ofTotalSeconds(-offset2);\n        const ldt2 = LocalDateTime.ofInstant(instant, zone2);\n\n        if(offset1 > offset2) {\n            return [ldt1, ldt2];\n        } else {\n            return [ldt2, ldt1];\n        }\n    }\n\n    _getTupple(index){\n        if (this._ldtUntils[index] == null) {\n            this._ldtUntils[index] = this._generateTupple(index);\n        }\n        return this._ldtUntils[index];\n    }\n\n    get(index) {\n        const ldtTupple = this._getTupple(index >> 1);\n        return ldtTupple[index % 2];\n    }\n}\n\n// modified bin-search, to always find existing indices for non-empty arrays\n// value in array at index is larger than input value (or last index of array)\nfunction ldtBinarySearch(array, value) {\n    let hi = array.size - 1, lo = -1, mid;\n    while (hi - lo > 1) {\n        if (!value.isBefore(array.get(mid = hi + lo >> 1))) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return hi;\n}\n\nfunction offsetInSeconds(tzdbOffset){\n    return roundDown(+tzdbOffset*60);\n}\n\nfunction roundDown(r){\n    if (r < 0) {\n        return Math.ceil(r);\n    } else {\n        return Math.floor(r);\n    }\n}\n\n// modified bin-search, to always find existing indices for non-empty arrays\n// value in array at index is larger than input value (or last index of array)\nfunction binarySearch(array, value) {\n    let hi = array.length - 1, lo = -1, mid;\n    while (hi - lo > 1) {\n        if (array[mid = hi + lo >> 1] <= value) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return hi;\n}\n\nfunction notSupported(msg){\n    throw new Error(`not supported: ${msg}`);\n}\n","/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {\n    DateTimeException,\n    ZoneRulesProvider,\n} from '@js-joda/core';\n\nimport { MomentZoneRules } from './MomentZoneRules';\n\nimport { unpack } from './unpack';\n\nlet TZDB_DATA;\nlet TZDB_VERSION;\nconst AVAILABLE_ZONE_IDS = [];\n\nconst zones = {};\nconst links = {};\n\nexport class MomentZoneRulesProvider extends ZoneRulesProvider {\n    /**\n     * Gets the rules for the zone ID.\n     * <p>\n     * This returns the latest available rules for the zone ID.\n     * <p>\n     * This method relies on time-zone data provider files that are configured.\n     *\n     * @param {string} zoneId\n     * @return {ZoneRules}\n     */\n    static getRules(zoneId){\n        const tzdbZoneInfo = zones[links[zoneId]];\n        if(tzdbZoneInfo == null){\n            throw new DateTimeException(`Unknown time-zone ID: ${zoneId}`);\n        }\n        return new MomentZoneRules(tzdbZoneInfo);\n    }\n\n\n    /**\n     * Gets the set of available zone IDs.\n     * <p>\n     * These zone IDs are loaded and available for use by {@code ZoneId}.\n     *\n     * @return {string[]} a modifiable copy of the set of zone IDs, not null\n     */\n    static getAvailableZoneIds(){\n        return AVAILABLE_ZONE_IDS;\n    }\n\n    /**\n     *\n     * @return {string} the tzdb version.\n     */\n    static getVersion() {\n        return TZDB_VERSION;\n    }\n\n    /**\n     * Provides the packed tzdb data,\n     * the data has the same format as provided from moment-timezone.\n     *\n     * @return {object} the packed tzdb data.\n     */\n    static getTzdbData(){\n        return TZDB_DATA;\n    }\n\n    /**\n     * Sets the packed tzdb data.\n     * Accepts tzdb data in the same format as provided from moment-timezone.\n     *\n     * @param packedJson\n     */\n    static loadTzdbData(packedJson){\n        TZDB_DATA = packedJson;\n        TZDB_VERSION = packedJson.version;\n\n        for (const packedZoneInfo of packedJson.zones) {\n            const tzdbZoneInfo = unpack(packedZoneInfo);\n            AVAILABLE_ZONE_IDS.push(tzdbZoneInfo.name);\n            zones[tzdbZoneInfo.name] = tzdbZoneInfo;\n            links[tzdbZoneInfo.name] = tzdbZoneInfo.name;\n        }\n\n        for (const packedLink of packedJson.links) {\n            const link = packedLink.split('|');\n            AVAILABLE_ZONE_IDS.push(link[1]);\n            links[link[1]] = link[0];\n        }\n    }\n}\n","/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { use } from '@js-joda/core';\n\nimport plug from './plug';\n\n/**\n * @private\n */\nexport default function autoPlug() {\n    use(plug);\n}\n\n","/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport latest from './tzdbData';\n\nimport { MomentZoneRulesProvider } from './MomentZoneRulesProvider';\nimport autoPlug from './auto-plug';\n\nMomentZoneRulesProvider.loadTzdbData(latest);\n\nautoPlug();\n","/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { MomentZoneRulesProvider } from './MomentZoneRulesProvider';\nimport extendSystemDefaultZoneId from './system-default-zone';\n\n/**\n * @private\n */\nexport default function (jsJoda) {\n    jsJoda.ZoneRulesProvider.getRules = MomentZoneRulesProvider.getRules;\n    jsJoda.ZoneRulesProvider.getAvailableZoneIds = MomentZoneRulesProvider.getAvailableZoneIds;\n    jsJoda.ZoneRulesProvider.getTzdbData = MomentZoneRulesProvider.getTzdbData;\n    jsJoda.ZoneRulesProvider.loadTzdbData = MomentZoneRulesProvider.loadTzdbData;\n\n    extendSystemDefaultZoneId(jsJoda.ZoneId);\n    return jsJoda;\n}\n","/**\n * @private\n *\n * @param ZoneId\n * @returns {null|*}\n */\nfunction getResolvedZoneId(ZoneId) {\n    try {\n        const resolvedTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        return ZoneId.of(resolvedTimeZone);\n    } catch (err) {\n        // ignore\n    }\n    return null;\n}\n\n/**\n * @private\n *\n * @param ZoneId\n */\nexport default function extendSystemDefaultZoneId(ZoneId) {\n    const resolvedZoneId = getResolvedZoneId(ZoneId);\n\n    if (resolvedZoneId == null) {\n        return;\n    }\n\n    ZoneId.systemDefault = function () {\n        return resolvedZoneId;\n    };\n}\n","import latest from '../data/packed/latest.json';\n\nexport default latest;\n","/* eslint-disable no-var */\n\n//! moment-timezone.js\n//! version : 0.5.2\n//! author : Tim Wood\n//! license : MIT\n//! github.com/moment/moment-timezone\n\n/************************************\n Unpacking\n ************************************/\n\n/**\n * @private\n *\n * @param charCode\n * @returns {number}\n */\nfunction charCodeToInt(charCode) {\n    if (charCode > 96) {\n        return charCode - 87;\n    } else if (charCode > 64) {\n        return charCode - 29;\n    }\n    return charCode - 48;\n}\n\nfunction unpackBase60(string) {\n    var i = 0,\n        parts = string.split('.'),\n        whole = parts[0],\n        fractional = parts[1] || '',\n        multiplier = 1,\n        num,\n        out = 0,\n        sign = 1;\n\n    // handle negative numbers\n    if (string.charCodeAt(0) === 45) {\n        i = 1;\n        sign = -1;\n    }\n\n    // handle digits before the decimal\n    for (i; i < whole.length; i++) {\n        num = charCodeToInt(whole.charCodeAt(i));\n        out = 60 * out + num;\n    }\n\n    // handle digits after the decimal\n    for (i = 0; i < fractional.length; i++) {\n        multiplier = multiplier / 60;\n        num = charCodeToInt(fractional.charCodeAt(i));\n        out += num * multiplier;\n    }\n\n    return out * sign;\n}\n\nfunction arrayToInt (array) {\n    for (var i = 0; i < array.length; i++) {\n        array[i] = unpackBase60(array[i]);\n    }\n}\n\nfunction intToUntil (array, length) {\n    for (var i = 0; i < length; i++) {\n        array[i] = Math.round((array[i - 1] || 0) + (array[i] * 60000)); // minutes to milliseconds\n    }\n\n    array[length - 1] = Infinity;\n}\n\nfunction mapIndices (source, indices) {\n    var out = [], i;\n\n    for (i = 0; i < indices.length; i++) {\n        out[i] = source[indices[i]];\n    }\n\n    return out;\n}\n\n/**\n * @private\n *\n * @param string\n * @returns {{offsets: *[], abbrs: *[], name, untils: *, population: number}}\n */\nexport function unpack (string) {\n    var data = string.split('|'),\n        offsets = data[2].split(' '),\n        indices = data[3].split(''),\n        untils  = data[4].split(' ');\n\n    arrayToInt(offsets);\n    arrayToInt(indices);\n    arrayToInt(untils);\n\n    intToUntil(untils, indices.length);\n\n    return {\n        name       : data[0],\n        abbrs      : mapIndices(data[1].split(' '), indices),\n        offsets    : mapIndices(offsets, indices),\n        untils     : untils,\n        population : data[5] | 0\n    };\n}\n\n","module.exports = __WEBPACK_EXTERNAL_MODULE__js_joda_core__;"],"sourceRoot":""}